/* Inline assembly
 * ================
 *
 * Rust provides support for inline assembly via the asm! macro. It can be used to embed
 * handwritten assembly in the assembly output generated by the compiler. Generally this should not
 * be necessary, but might be where the required performance or timing cannot be otherwise
 * achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this
 * functionality.
 *
 * ---
 * Note: the examples here are given in x86/x86-64 assembly, but other architectures are also
 * supported.
 * ---
 *
 * Inline assembly is currently supported on the following architectures:
 *
 *  - x86 and x86-64
 *  - ARM
 *  - AArch64
 *  - RISC-V
 *
 *
 *
 * Basic usage
 * -------------
 *
 * Let us start with the simplest possible example:
 */

use std::arch::asm;

fn ex1() {
    unsafe {
        asm!("nop");
    }
}

/* This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
 * Note that all asm! invocations have to be inside an unsafe block, as they could insert arbitrary
 * instructions and break various invariants. The instructions to be inserted are listed in the
 * first argument of the asm! macro as a string literal. 
 * 
 *
 * Inputs and Outputs
 * ---------------------
 *
 * Now inserting an instruction that does nothing is rather boring. Let us do something that
 * actually acts on data: */
fn ex2() {
    let x: u64;
    unsafe {
        asm!("mov {}, 5", out(reg) x);
    }

    assert_eq!(x, 5);
}

/* This will write the value 5 into the u64 variable x. You can see that the string literal we use
 * to specify instructions is actually a template string. It is governed by the same rules as Rust
 * format strings. The arguments that are inserted into the template however look at bit different
 * that you might be familiar with. First we need to specify if the variable is an input or an
 * output of the inline assembly. In this case it is an output. We declared this by writing out. We
 * also need to specify in what kind of register the assembly expects the variable. In this case we
 * put it in an arbitrary general purpose register by specifying reg. The compiler will choose an
 * appropriate register to insert into the template and will read the variable from there after the
 * inline assembly finishes executing. 
 *
 * Let us see another example that also uses an input:*/

fn ex3() {
    let i: u64 = 3;
    let o: u64;

    unsafe {
        asm!(
            "mov {0}, {1}",
            "add {0}, 5",
            out(reg) o,
            in(reg) i,
        );
    }
    assert_eq!(o, 8);
}

/* This will add 5 to the input in variable i and write the result to variable o. The particular
 * way this assembly does this is first copying the value from i to the output, and then adding 5
 * to it. 
 *
 * The example shows a few things:
 *
 * First, we can see that asm! allows multiple template string arguments; each one is treated as a
 * separate line of assembly code, as if they were all joined together with newlines between them.
 * This makes it easy to format assembly code.
 *
 * Second, we can see that inputs are declared by writing in instead of out.
 *
 * Tjhisrd, we can see that we can specify an argument number, or name as in any format string. For
 * inline assembly templates this is particulary useful as arguments are often used more than
 * once. For more complex inline assembly using this facility is generally recommended, as it
 * improves readability, and allows reordeing instructions without changing the argument order.
 *
 * We can further refine the above example to avoid the mov instruction: */

fn ex4() {
    let mut x: u64 = 3;
    unsafe {
        asm!("add {0}, 5", inout(reg) x);
    }
    assert_eq!(x, 8);
}

/* We can see that inout is used to specify tan argument that is both input and output. This is
 * different from specifying an input and output separately in that it is guaranteed to assign both
 * to the same register.
 *
 * It is also possible to specify different variables for the input and output parts of an inout
 * operand: */

fn ex5() {
    let x: u64 = 3;
    let y: u64;
    unsafe {
        asm!("add {0}, 5", inout(reg) x => y);
    }
    assert_eq!(y, 8);
}


/* Late output operands
 * ----------------------
 *
 * The Rust compiler is conservative with its allocation of operands. It is assumed that an out can
 * be written at any time, and can therefore not share its location with any other argument.
 * However, to guarantee optimal performance it is important to use as few registers as possible,
 * so they won't have to be saved and reloaded around the inline assembly block. To achieve this
 * Rust provides a lateout specifier. This can be used on any output that is written only after all
 * inputs have been consumed. There is also inlateout variant of this specifier.
 *
 * Here is an example where inlateout -cannot- be used in release mode or other optimized cases:
 */

fn ex6() {
    let mut a: u64 = 4;
    let b: u64 = 4;
    let c: u64 = 4;

    unsafe {
        asm!(
            "add {0}, {1}",
            "add {0}, {2}",
            inout(reg) a,
            in(reg) b,
            in(reg) c,
        );
    }
    assert_eq!(a, 12);
}

/* YOU KNOW WHAT? I'm going to skip the rest of this chapter. Assembly is WAY out of my scope. I
 * know its possible, but more examples just gonna make me more confused about Rust which is what
 * I'm here for. 
 *
 * So to future me: if you need to dig into this, look up the rest of the article here:
 * https://doc.rust-lang.org/rust-by-example/unsafe/asm.html
 *
 */


fn main() {
    ex1();
    ex2();
    
    ex3();
}
